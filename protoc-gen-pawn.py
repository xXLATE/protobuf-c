#!/usr/bin/env python3
"""
protoc-gen-pawn: Protocol Buffer compiler plugin for Pawn language

This script serves as a protoc plugin to generate Pawn include files
from Protocol Buffer definitions.

Usage:
  protoc --plugin=protoc-gen-pawn=protoc-gen-pawn.py --pawn_out=. test.proto
"""

import sys
import re
from google.protobuf.compiler import plugin_pb2 as plugin
from google.protobuf.descriptor_pb2 import FileDescriptorProto, DescriptorProto, EnumDescriptorProto

def enum_value_name(value):
    """Convert enum value to Pawn constant name."""
    return value.name.upper()

def message_enum_name(message):
    """Generate enum name for message structure."""
    return f"E_{message.name.upper()}_DATA"

def message_field_name(field):
    """Generate field name for message enum."""
    return f"P_{field.name.upper()}"

def filename_to_pawn_guard(filename):
    """Convert filename to include guard."""
    name = filename.replace('.proto', '').replace('/', '_').replace('\\', '_').replace('.', '_').upper()
    return f"__{name}_PB_PAWN_INC__"

def filename_to_pawn_include(filename):
    """Convert proto filename to .inc filename."""
    return filename.replace('.proto', '.pb-pawn.inc')

def generate_enum(enum, output):
    """Generate Pawn constants for an enum."""
    output.append(f"// Enum: {enum.name}")
    for value in enum.value:
        const_name = enum_value_name(value)
        output.append(f"#define {const_name} {value.number}")
    output.append("")

def generate_message_enum(message, output):
    """Generate enum definition for a message."""
    enum_name = message_enum_name(message)
    output.append(f"// Message: {message.name}")
    output.append(f"enum {enum_name} {{")
    
    field_count = 0
    for field in message.field:
        field_name = message_field_name(field)
        output.append(f"    {field_name} = {field_count},")
        field_count += 1
    
    output.append("}")
    output.append("")

def generate_message_and_nested(message, output):
    """Generate message enum and all nested types."""
    # Generate enum for this message
    generate_message_enum(message, output)
    
    # Generate nested enums
    for nested_enum in message.enum_type:
        generate_enum(nested_enum, output)
    
    # Generate nested messages recursively
    for nested_message in message.nested_type:
        generate_message_and_nested(nested_message, output)

def generate_file(file_desc, output):
    """Generate Pawn code for a .proto file."""
    # File header
    output.append("/* Generated by the protocol buffer compiler for Pawn. DO NOT EDIT! */")
    output.append(f"/* source: {file_desc.name} */")
    output.append("")
    
    # Include guard
    guard = filename_to_pawn_guard(file_desc.name)
    output.append(f"#if defined {guard}")
    output.append("#endinput")
    output.append("#endif")
    output.append(f"#define {guard}")
    output.append("")
    
    # Dependencies
    for dep in file_desc.dependency:
        include_name = filename_to_pawn_include(dep)
        output.append(f'#include "{include_name}"')
    if file_desc.dependency:
        output.append("")
    
    # Top-level enums
    for enum in file_desc.enum_type:
        generate_enum(enum, output)
    
    # Messages and nested types
    for message in file_desc.message_type:
        generate_message_and_nested(message, output)
    
    # Services (placeholder)
    if file_desc.service:
        output.append("// Service Descriptors")
        for service in file_desc.service:
            output.append(f"// Service: {service.name}")
            output.append(f"// Method count: {len(service.method)}")
            output.append("")

def main():
    """Main entry point for protoc plugin"""
    try:
        # Read request from stdin (binary protobuf data)
        data = sys.stdin.buffer.read()
        request = plugin.CodeGeneratorRequest()
        request.ParseFromString(data)
        
        # Create response
        response = plugin.CodeGeneratorResponse()
        
        for proto_file in request.proto_file:
            if proto_file.name in request.file_to_generate:
                output_lines = []
                generate_file(proto_file, output_lines)
                
                output_filename = proto_file.name.replace('.proto', '.pb-pawn.inc')
                
                output_file = response.file.add()
                output_file.name = output_filename
                output_file.content = '\n'.join(output_lines)
        
        # Write response to stdout (binary protobuf data)
        sys.stdout.buffer.write(response.SerializeToString())
        
    except Exception as e:
        # Error handling
        response = plugin.CodeGeneratorResponse()
        response.error = f"protoc-gen-pawn error: {str(e)}"
        sys.stdout.buffer.write(response.SerializeToString())
        return 1
    
    return 0


if __name__ == '__main__':
    sys.exit(main()) 