#include <iostream>
#include <fstream>
#include <string>
#include <vector>

// Simple standalone version of protoc-gen-pawn
// This version reads proto files and generates basic Pawn definitions

struct ProtoEnum {
    std::string name;
    std::vector<std::pair<std::string, int>> values;
};

struct ProtoMessage {
    std::string name;
    std::vector<std::string> fields;
};

class SimplePawnGenerator {
public:
    void generateFromProto(const std::string& proto_content, std::ostream& output) {
        output << "/* Generated by protoc-gen-pawn standalone version */\n";
        output << "#if defined _protobuf_pawn_included\n";
        output << "  #endinput\n";
        output << "#endif\n";
        output << "#define _protobuf_pawn_included\n\n";
        
        // Parse and generate enums
        parseAndGenerateEnums(proto_content, output);
        
        // Parse and generate messages  
        parseAndGenerateMessages(proto_content, output);
        
        output << "\n/* End of generated file */\n";
    }

private:
    void parseAndGenerateEnums(const std::string& content, std::ostream& output) {
        size_t pos = 0;
        while ((pos = content.find("enum ", pos)) != std::string::npos) {
            // Extract enum name
            size_t name_start = pos + 5;
            size_t name_end = content.find(" {", name_start);
            if (name_end == std::string::npos) {
                pos++;
                continue;
            }
            
            std::string enum_name = content.substr(name_start, name_end - name_start);
            
            // Find enum body
            size_t body_start = content.find("{", name_end);
            size_t body_end = content.find("}", body_start);
            if (body_start == std::string::npos || body_end == std::string::npos) {
                pos++;
                continue;
            }
            
            output << "/* " << enum_name << " values */\n";
            
            // Parse enum values
            std::string enum_body = content.substr(body_start + 1, body_end - body_start - 1);
            size_t line_pos = 0;
            while ((line_pos = enum_body.find_first_not_of(" \t\n\r", line_pos)) != std::string::npos) {
                size_t line_end = enum_body.find_first_of(";\n", line_pos);
                if (line_end == std::string::npos) break;
                
                std::string line = enum_body.substr(line_pos, line_end - line_pos);
                
                // Parse "VALUE = number"
                size_t eq_pos = line.find("=");
                if (eq_pos != std::string::npos) {
                    std::string value_name = line.substr(0, eq_pos);
                    std::string value_num = line.substr(eq_pos + 1);
                    
                    // Trim whitespace
                    value_name.erase(0, value_name.find_first_not_of(" \t"));
                    value_name.erase(value_name.find_last_not_of(" \t") + 1);
                    value_num.erase(0, value_num.find_first_not_of(" \t"));
                    value_num.erase(value_num.find_last_not_of(" \t") + 1);
                    
                    // Convert to uppercase for enum name
                    std::string upper_enum = enum_name;
                    for (char& c : upper_enum) c = std::toupper(c);
                    
                    output << "#define " << upper_enum << "__" << value_name << " " << value_num << "\n";
                }
                
                line_pos = line_end + 1;
            }
            
            output << "\n";
            pos = body_end + 1;
        }
    }
    
    void parseAndGenerateMessages(const std::string& content, std::ostream& output) {
        size_t pos = 0;
        while ((pos = content.find("message ", pos)) != std::string::npos) {
            // Extract message name
            size_t name_start = pos + 8;
            size_t name_end = content.find(" {", name_start);
            if (name_end == std::string::npos) {
                pos++;
                continue;
            }
            
            std::string message_name = content.substr(name_start, name_end - name_start);
            
            output << "/* " << message_name << " message constants */\n";
            output << "// TODO: Add field constants for " << message_name << "\n\n";
            
            pos = name_end + 1;
        }
    }
};

int main(int argc, char* argv[]) {
    // Simple version - read from stdin, write to stdout
    std::string input_content;
    std::string line;
    
    while (std::getline(std::cin, line)) {
        input_content += line + "\n";
    }
    
    SimplePawnGenerator generator;
    generator.generateFromProto(input_content, std::cout);
    
    return 0;
} 